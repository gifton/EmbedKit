import Foundation
import Testing
import Security
import CryptoKit
@testable import EmbedKit

@Suite("Security Components Tests")
struct SecurityTests {
    
    // MARK: - ModelSignatureVerifier Tests
    
    @Test("Generate RSA key pair")
    func testGenerateKeyPair() throws {
        let (privateKey, publicKey) = try ModelSignatureVerifier.generateKeyPair()
        
        // Verify keys are valid
        #expect(SecKeyIsAlgorithmSupported(privateKey, .sign, .rsaSignatureMessagePKCS1v15SHA256))
        #expect(SecKeyIsAlgorithmSupported(publicKey, .verify, .rsaSignatureMessagePKCS1v15SHA256))
        
        // Verify key sizes
        let privateKeyAttributes = SecKeyCopyAttributes(privateKey) as! [String: Any]
        let publicKeyAttributes = SecKeyCopyAttributes(publicKey) as! [String: Any]
        
        #expect(privateKeyAttributes[kSecAttrKeySizeInBits as String] as? Int == 2048)
        #expect(publicKeyAttributes[kSecAttrKeySizeInBits as String] as? Int == 2048)
    }
    
    @Test("Sign and verify model")
    func testSignAndVerifyModel() async throws {
        let verifier = ModelSignatureVerifier(trustedSigners: ["test-signer"])
        let (privateKey, publicKey) = try ModelSignatureVerifier.generateKeyPair()
        
        // Create test model file
        let tempDir = FileManager.default.temporaryDirectory.appendingPathComponent("SecurityTest_\(UUID())")
        try FileManager.default.createDirectory(at: tempDir, withIntermediateDirectories: true)
        
        let modelFile = tempDir.appendingPathComponent("test_model.mlmodel")
        let modelData = "This is a test model for signature verification".data(using: .utf8)!
        try modelData.write(to: modelFile)
        
        // Sign the model
        let signature = try await verifier.signModel(
            fileURL: modelFile,
            signerIdentity: "test-signer",
            privateKey: privateKey
        )
        
        // Verify signature fields
        #expect(signature.info.signerIdentity == "test-signer")
        #expect(signature.info.fileName == "test_model.mlmodel")
        #expect(signature.info.fileSize == modelData.count)
        #expect(signature.info.hashAlgorithm == "SHA256")
        #expect(signature.info.signatureAlgorithm == "RSA-PKCS1")
        #expect(!signature.signature.isEmpty)
        #expect(!signature.publicKeyFingerprint.isEmpty)
        
        // Verify the signature
        let result = try await verifier.verifySignature(
            for: modelFile,
            signature: signature,
            publicKey: publicKey
        )
        
        #expect(result.isValid)
        #expect(result.trustLevel == .trusted)
        #expect(result.issues.isEmpty)
        #expect(result.signerIdentity == "test-signer")
        
        // Cleanup
        try? FileManager.default.removeItem(at: tempDir)
    }
    
    @Test("Detect file tampering")
    func testDetectFileTampering() async throws {
        let verifier = ModelSignatureVerifier()
        let (privateKey, publicKey) = try ModelSignatureVerifier.generateKeyPair()
        
        let tempDir = FileManager.default.temporaryDirectory.appendingPathComponent("SecurityTest_\(UUID())")
        try FileManager.default.createDirectory(at: tempDir, withIntermediateDirectories: true)
        
        let modelFile = tempDir.appendingPathComponent("tamper_test.mlmodel")
        try "Original model content".data(using: .utf8)!.write(to: modelFile)
        
        // Sign the original file
        let signature = try await verifier.signModel(
            fileURL: modelFile,
            signerIdentity: "test-signer",
            privateKey: privateKey
        )
        
        // Tamper with the file
        try "Tampered model content!!!".data(using: .utf8)!.write(to: modelFile)
        
        // Verify should fail
        let result = try await verifier.verifySignature(
            for: modelFile,
            signature: signature,
            publicKey: publicKey
        )
        
        #expect(!result.isValid)
        #expect(result.issues.contains { issue in
            if case .fileSizeChanged = issue { return true }
            return false
        })
        
        // Cleanup
        try? FileManager.default.removeItem(at: tempDir)
    }
    
    @Test("Trust level verification")
    func testTrustLevelVerification() async throws {
        let trustedSigner = "trusted-org"
        let untrustedSigner = "unknown-org"
        
        let verifier = ModelSignatureVerifier(trustedSigners: [trustedSigner])
        let (privateKey, publicKey) = try ModelSignatureVerifier.generateKeyPair()
        
        let tempDir = FileManager.default.temporaryDirectory.appendingPathComponent("SecurityTest_\(UUID())")
        try FileManager.default.createDirectory(at: tempDir, withIntermediateDirectories: true)
        
        let modelFile = tempDir.appendingPathComponent("trust_test.mlmodel")
        try "Test model".data(using: .utf8)!.write(to: modelFile)
        
        // Test trusted signer
        let trustedSignature = try await verifier.signModel(
            fileURL: modelFile,
            signerIdentity: trustedSigner,
            privateKey: privateKey
        )
        
        var result = try await verifier.verifySignature(
            for: modelFile,
            signature: trustedSignature,
            publicKey: publicKey
        )
        
        #expect(result.isValid)
        #expect(result.trustLevel == .trusted)
        
        // Test untrusted signer
        let untrustedSignature = try await verifier.signModel(
            fileURL: modelFile,
            signerIdentity: untrustedSigner,
            privateKey: privateKey
        )
        
        result = try await verifier.verifySignature(
            for: modelFile,
            signature: untrustedSignature,
            publicKey: publicKey
        )
        
        #expect(result.isValid)
        #expect(result.trustLevel == .validButUntrusted)
        
        // Cleanup
        try? FileManager.default.removeItem(at: tempDir)
    }
    
    @Test("Signature age validation")
    func testSignatureAgeValidation() async throws {
        let verifier = ModelSignatureVerifier()
        let (privateKey, publicKey) = try ModelSignatureVerifier.generateKeyPair()
        
        let tempDir = FileManager.default.temporaryDirectory.appendingPathComponent("SecurityTest_\(UUID())")
        try FileManager.default.createDirectory(at: tempDir, withIntermediateDirectories: true)
        
        let modelFile = tempDir.appendingPathComponent("age_test.mlmodel")
        try "Test model".data(using: .utf8)!.write(to: modelFile)
        
        // Create an old signature (manually set old date)
        let oldDate = Date().addingTimeInterval(-400 * 24 * 60 * 60) // 400 days ago
        
        let oldInfo = ModelSignatureInfo(
            fileName: modelFile.lastPathComponent,
            fileSize: 10,
            hashAlgorithm: "SHA256",
            signatureAlgorithm: "RSA-PKCS1",
            signerIdentity: "test-signer",
            signedAt: oldDate,
            version: "1.0"
        )
        
        // Create a valid signature but with old timestamp
        let signature = try await verifier.signModel(
            fileURL: modelFile,
            signerIdentity: "test-signer",
            privateKey: privateKey
        )
        
        let oldSignature = ModelSignature(
            signature: signature.signature,
            info: oldInfo,
            publicKeyFingerprint: signature.publicKeyFingerprint
        )
        
        let result = try await verifier.verifySignature(
            for: modelFile,
            signature: oldSignature,
            publicKey: publicKey
        )
        
        #expect(!result.isValid)
        #expect(result.issues.contains { issue in
            if case .signatureTooOld = issue { return true }
            return false
        })
        
        // Cleanup
        try? FileManager.default.removeItem(at: tempDir)
    }
    
    @Test("Invalid signature format detection")
    func testInvalidSignatureFormatDetection() async throws {
        let verifier = ModelSignatureVerifier()
        
        // Test various invalid formats
        let invalidSignatures = [
            ModelSignature(
                signature: "not-base64!!!",
                info: ModelSignatureInfo(
                    fileName: "test.mlmodel",
                    fileSize: 100,
                    hashAlgorithm: "SHA256",
                    signatureAlgorithm: "RSA-PKCS1",
                    signerIdentity: "test",
                    signedAt: Date(),
                    version: "1.0"
                ),
                publicKeyFingerprint: "test"
            ),
            ModelSignature(
                signature: Data("valid".utf8).base64EncodedString(),
                info: ModelSignatureInfo(
                    fileName: "",  // Empty filename
                    fileSize: 100,
                    hashAlgorithm: "SHA256",
                    signatureAlgorithm: "RSA-PKCS1",
                    signerIdentity: "test",
                    signedAt: Date(),
                    version: "1.0"
                ),
                publicKeyFingerprint: "test"
            ),
            ModelSignature(
                signature: Data("valid".utf8).base64EncodedString(),
                info: ModelSignatureInfo(
                    fileName: "test.mlmodel",
                    fileSize: -1,  // Invalid file size
                    hashAlgorithm: "SHA256",
                    signatureAlgorithm: "RSA-PKCS1",
                    signerIdentity: "test",
                    signedAt: Date(),
                    version: "1.0"
                ),
                publicKeyFingerprint: "test"
            )
        ]
        
        for (index, invalidSig) in invalidSignatures.enumerated() {
            let isValid = await verifier.validateSignatureFormat(invalidSig)
            #expect(!isValid, "Invalid signature \(index) should not pass validation")
        }
        
        // Test valid format
        let validSignature = ModelSignature(
            signature: Data("valid".utf8).base64EncodedString(),
            info: ModelSignatureInfo(
                fileName: "test.mlmodel",
                fileSize: 100,
                hashAlgorithm: "SHA256",
                signatureAlgorithm: "RSA-PKCS1",
                signerIdentity: "test",
                signedAt: Date(),
                version: "1.0"
            ),
            publicKeyFingerprint: "test"
        )
        
        let isValid = await verifier.validateSignatureFormat(validSignature)
        #expect(isValid)
    }
    
    @Test("Key fingerprint verification")
    func testKeyFingerprintVerification() async throws {
        let verifier = ModelSignatureVerifier()
        let (privateKey1, publicKey1) = try ModelSignatureVerifier.generateKeyPair()
        let (_, publicKey2) = try ModelSignatureVerifier.generateKeyPair()
        
        let tempDir = FileManager.default.temporaryDirectory.appendingPathComponent("SecurityTest_\(UUID())")
        try FileManager.default.createDirectory(at: tempDir, withIntermediateDirectories: true)
        
        let modelFile = tempDir.appendingPathComponent("fingerprint_test.mlmodel")
        try "Test model".data(using: .utf8)!.write(to: modelFile)
        
        // Sign with first key
        let signature = try await verifier.signModel(
            fileURL: modelFile,
            signerIdentity: "test-signer",
            privateKey: privateKey1
        )
        
        // Verify with correct key - should pass
        var result = try await verifier.verifySignature(
            for: modelFile,
            signature: signature,
            publicKey: publicKey1
        )
        
        #expect(result.isValid)
        #expect(result.issues.isEmpty)
        
        // Try to verify with wrong key - should fail
        result = try await verifier.verifySignature(
            for: modelFile,
            signature: signature,
            publicKey: publicKey2
        )
        
        #expect(!result.isValid)
        #expect(result.issues.contains { issue in
            if case .signatureVerificationFailed = issue { return true }
            return false
        })
        
        // Cleanup
        try? FileManager.default.removeItem(at: tempDir)
    }
    
    @Test("Signed model package save and load")
    func testSignedModelPackageSaveAndLoad() async throws {
        let verifier = ModelSignatureVerifier()
        let (privateKey, _) = try ModelSignatureVerifier.generateKeyPair()
        
        let tempDir = FileManager.default.temporaryDirectory.appendingPathComponent("SecurityTest_\(UUID())")
        try FileManager.default.createDirectory(at: tempDir, withIntermediateDirectories: true)
        
        let modelFile = tempDir.appendingPathComponent("package_test.mlmodel")
        try "Package test model".data(using: .utf8)!.write(to: modelFile)
        
        // Create signature
        let signature = try await verifier.signModel(
            fileURL: modelFile,
            signerIdentity: "package-signer",
            privateKey: privateKey
        )
        
        // Create package
        let metadata = ["version": "1.0", "author": "Test Author"]
        let package = SignedModelPackage(
            modelURL: modelFile,
            signature: signature,
            metadata: metadata
        )
        
        // Save package
        let packageDir = tempDir.appendingPathComponent("packages")
        try package.save(to: packageDir)
        
        // Verify package structure
        let expectedPackageDir = packageDir.appendingPathComponent("package_test.embedkit")
        #expect(FileManager.default.fileExists(atPath: expectedPackageDir.path))
        #expect(FileManager.default.fileExists(atPath: expectedPackageDir.appendingPathComponent("package_test.mlmodel").path))
        #expect(FileManager.default.fileExists(atPath: expectedPackageDir.appendingPathComponent("signature.json").path))
        #expect(FileManager.default.fileExists(atPath: expectedPackageDir.appendingPathComponent("package.json").path))
        
        // Load package
        let loadedPackage = try SignedModelPackage.load(from: expectedPackageDir)
        
        #expect(loadedPackage.signature.info.signerIdentity == "package-signer")
        #expect(loadedPackage.metadata["version"] == "1.0")
        #expect(loadedPackage.metadata["author"] == "Test Author")
        #expect(FileManager.default.fileExists(atPath: loadedPackage.modelURL.path))
        
        // Cleanup
        try? FileManager.default.removeItem(at: tempDir)
    }
    
    @Test("Store and retrieve trusted public key")
    func testStoreAndRetrieveTrustedPublicKey() async throws {
        let verifier = ModelSignatureVerifier(useKeychain: true)
        let (_, publicKey) = try ModelSignatureVerifier.generateKeyPair()
        
        let identity = "test-keychain-identity-\(UUID())"
        
        // Store key
        try await verifier.storeTrustedPublicKey(publicKey, for: identity)
        
        // Sign a model with different private key to test retrieval
        let (_, _) = try ModelSignatureVerifier.generateKeyPair()
        
        let tempDir = FileManager.default.temporaryDirectory.appendingPathComponent("SecurityTest_\(UUID())")
        try FileManager.default.createDirectory(at: tempDir, withIntermediateDirectories: true)
        
        let modelFile = tempDir.appendingPathComponent("keychain_test.mlmodel")
        try "Keychain test".data(using: .utf8)!.write(to: modelFile)
        
        // This signature will be created with privateKey2 but we'll verify with stored publicKey
        // For this test, we need to sign with the matching private key
        let (matchingPrivateKey, matchingPublicKey) = try ModelSignatureVerifier.generateKeyPair()
        
        // Store the matching public key
        try await verifier.storeTrustedPublicKey(matchingPublicKey, for: identity)
        
        let signature = try await verifier.signModel(
            fileURL: modelFile,
            signerIdentity: identity,
            privateKey: matchingPrivateKey
        )
        
        // Verify without providing public key - should retrieve from keychain
        let result = try await verifier.verifySignature(
            for: modelFile,
            signature: signature,
            publicKey: nil  // Let it retrieve from keychain
        )
        
        #expect(result.isValid)
        
        // Cleanup keychain
        let query: [String: Any] = [
            kSecClass as String: kSecClassKey,
            kSecAttrApplicationLabel as String: "EmbedKit-\(identity)"
        ]
        SecItemDelete(query as CFDictionary)
        
        // Cleanup files
        try? FileManager.default.removeItem(at: tempDir)
    }
    
    @Test("Handle missing file for signing")
    func testHandleMissingFileForSigning() async throws {
        let verifier = ModelSignatureVerifier()
        let (privateKey, _) = try ModelSignatureVerifier.generateKeyPair()
        
        let nonExistentFile = URL(fileURLWithPath: "/tmp/non_existent_model_\(UUID()).mlmodel")
        
        await #expect(throws: Error.self) {
            _ = try await verifier.signModel(
                fileURL: nonExistentFile,
                signerIdentity: "test",
                privateKey: privateKey
            )
        }
    }
    
    @Test("Handle missing file for verification")
    func testHandleMissingFileForVerification() async throws {
        let verifier = ModelSignatureVerifier()
        let (_, publicKey) = try ModelSignatureVerifier.generateKeyPair()
        
        let nonExistentFile = URL(fileURLWithPath: "/tmp/non_existent_model_\(UUID()).mlmodel")
        
        let dummySignature = ModelSignature(
            signature: Data("dummy".utf8).base64EncodedString(),
            info: ModelSignatureInfo(
                fileName: "test.mlmodel",
                fileSize: 100,
                hashAlgorithm: "SHA256",
                signatureAlgorithm: "RSA-PKCS1",
                signerIdentity: "test",
                signedAt: Date(),
                version: "1.0"
            ),
            publicKeyFingerprint: "dummy"
        )
        
        await #expect(throws: Error.self) {
            _ = try await verifier.verifySignature(
                for: nonExistentFile,
                signature: dummySignature,
                publicKey: publicKey
            )
        }
    }
    
    @Test("Sequential signature operations")
    func testSequentialSignatureOperations() async throws {
        let verifier = ModelSignatureVerifier()
        
        let tempDir = FileManager.default.temporaryDirectory.appendingPathComponent("SecurityTest_\(UUID())")
        try FileManager.default.createDirectory(at: tempDir, withIntermediateDirectories: true)
        
        // Create multiple key pairs and files
        let operations = 3
        
        for i in 0..<operations {
            let (privateKey, publicKey) = try ModelSignatureVerifier.generateKeyPair()
            
            let modelFile = tempDir.appendingPathComponent("sequential_\(i).mlmodel")
            try "Model \(i) content".data(using: .utf8)!.write(to: modelFile)
            
            // Sign
            let signature = try await verifier.signModel(
                fileURL: modelFile,
                signerIdentity: "signer-\(i)",
                privateKey: privateKey
            )
            
            // Verify
            let result = try await verifier.verifySignature(
                for: modelFile,
                signature: signature,
                publicKey: publicKey
            )
            
            #expect(result.isValid)
        }
        
        // Cleanup
        try? FileManager.default.removeItem(at: tempDir)
    }
}