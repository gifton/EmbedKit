import Foundation
import OSLog

/// Benchmark results reporter and analysis tool
public struct BenchmarkReporter {
    private let logger = Logger(subsystem: "EmbedKit", category: "BenchmarkReporter")
    
    public init() {}
    
    /// Generate a comprehensive report from benchmark results
    public func generateReport(_ results: BenchmarkSuiteResults) -> BenchmarkReport {
        let analysis = analyzeResults(results)
        let recommendations = generateRecommendations(results, analysis: analysis)
        
        return BenchmarkReport(
            results: results,
            analysis: analysis,
            recommendations: recommendations,
            generatedAt: Date()
        )
    }
    
    /// Export benchmark results to JSON
    public func exportToJSON(_ results: BenchmarkSuiteResults) throws -> Data {
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .iso8601
        encoder.outputFormatting = .prettyPrinted
        return try encoder.encode(results)
    }
    
    /// Export benchmark report to markdown
    public func exportToMarkdown(_ report: BenchmarkReport) -> String {
        var markdown = """
        # EmbedKit Benchmark Report
        
        **Generated:** \(DateFormatter.iso8601.string(from: report.generatedAt))  
        **Total Time:** \(String(format: "%.2f", report.results.totalTime))s
        
        ## Summary
        
        \(generateSummarySection(report))
        
        ## Detailed Results
        
        """
        
        markdown += generateEmbeddingSection(report.results.embedding)
        markdown += generateMetalSection(report.results.metal)
        markdown += generateCacheSection(report.results.cache)
        markdown += generateStreamingSection(report.results.streaming)
        markdown += generateModelManagementSection(report.results.modelManagement)
        markdown += generateMemorySection(report.results.memory)
        markdown += generateConcurrencySection(report.results.concurrency)
        
        markdown += """
        
        ## Performance Analysis
        
        \(generateAnalysisSection(report.analysis))
        
        ## Recommendations
        
        \(generateRecommendationsSection(report.recommendations))
        
        ---
        *Generated by EmbedKit Benchmark Suite*
        """
        
        return markdown
    }
    
    /// Compare two benchmark results
    public func compareResults(_ current: BenchmarkSuiteResults, _ baseline: BenchmarkSuiteResults) -> BenchmarkComparison {
        return BenchmarkComparison(
            embedding: compareEmbedding(current.embedding, baseline.embedding),
            metal: compareMetal(current.metal, baseline.metal),
            cache: compareCache(current.cache, baseline.cache),
            streaming: compareStreaming(current.streaming, baseline.streaming),
            modelManagement: compareModelManagement(current.modelManagement, baseline.modelManagement),
            memory: compareMemory(current.memory, baseline.memory),
            concurrency: compareConcurrency(current.concurrency, baseline.concurrency),
            overallImprovement: calculateOverallImprovement(current, baseline)
        )
    }
    
    // MARK: - Private Analysis Methods
    
    private func analyzeResults(_ results: BenchmarkSuiteResults) -> BenchmarkAnalysis {
        return BenchmarkAnalysis(
            overallPerformanceScore: calculateOverallScore(results),
            bottlenecks: identifyBottlenecks(results),
            strengths: identifyStrengths(results),
            resourceUtilization: analyzeResourceUtilization(results),
            scalabilityMetrics: analyzeScalability(results)
        )
    }
    
    private func calculateOverallScore(_ results: BenchmarkSuiteResults) -> Double {
        var score = 0.0
        var components = 0
        
        // Embedding performance (weight: 30%)
        if results.embedding.singleEmbeddingLatency < 0.01 { score += 30 }
        else if results.embedding.singleEmbeddingLatency < 0.05 { score += 20 }
        else if results.embedding.singleEmbeddingLatency < 0.1 { score += 10 }
        components += 1
        
        // Metal acceleration (weight: 20%)
        if results.metal.isMetalAvailable {
            let avgSpeedup = (results.metal.normalizationSpeedup + 
                            results.metal.poolingSpeedup + 
                            results.metal.cosineSimilaritySpeedup) / 3.0
            if avgSpeedup > 3.0 { score += 20 }
            else if avgSpeedup > 2.0 { score += 15 }
            else if avgSpeedup > 1.5 { score += 10 }
        }
        components += 1
        
        // Cache efficiency (weight: 15%)
        if results.cache.hitRate > 0.9 { score += 15 }
        else if results.cache.hitRate > 0.8 { score += 12 }
        else if results.cache.hitRate > 0.7 { score += 8 }
        components += 1
        
        // Concurrency scaling (weight: 20%)
        if results.concurrency.concurrencySpeedup > 4.0 { score += 20 }
        else if results.concurrency.concurrencySpeedup > 2.0 { score += 15 }
        else if results.concurrency.concurrencySpeedup > 1.5 { score += 10 }
        components += 1
        
        // Memory efficiency (weight: 15%)
        if results.memory.memoryLeakage < 1.0 { score += 15 }
        else if results.memory.memoryLeakage < 5.0 { score += 10 }
        else if results.memory.memoryLeakage < 10.0 { score += 5 }
        components += 1
        
        return score
    }
    
    private func identifyBottlenecks(_ results: BenchmarkSuiteResults) -> [PerformanceBottleneck] {
        var bottlenecks: [PerformanceBottleneck] = []
        
        // Check embedding latency
        if results.embedding.singleEmbeddingLatency > 0.1 {
            bottlenecks.append(.highEmbeddingLatency(results.embedding.singleEmbeddingLatency))
        }
        
        // Check cache performance
        if results.cache.hitRate < 0.7 {
            bottlenecks.append(.lowCacheHitRate(results.cache.hitRate))
        }
        
        // Check memory usage
        if results.memory.memoryLeakage > 10.0 {
            bottlenecks.append(.memoryLeaks(results.memory.memoryLeakage))
        }
        
        // Check concurrency scaling
        if results.concurrency.concurrencySpeedup < 1.5 {
            bottlenecks.append(.poorConcurrencyScaling(results.concurrency.concurrencySpeedup))
        }
        
        return bottlenecks
    }
    
    private func identifyStrengths(_ results: BenchmarkSuiteResults) -> [PerformanceStrength] {
        var strengths: [PerformanceStrength] = []
        
        // Check Metal acceleration
        if results.metal.isMetalAvailable {
            let avgSpeedup = (results.metal.normalizationSpeedup + 
                            results.metal.poolingSpeedup + 
                            results.metal.cosineSimilaritySpeedup) / 3.0
            if avgSpeedup > 2.0 {
                strengths.append(.metalAcceleration(avgSpeedup))
            }
        }
        
        // Check batch processing
        if results.embedding.batchSpeedup > 2.0 {
            strengths.append(.efficientBatchProcessing(results.embedding.batchSpeedup))
        }
        
        // Check streaming
        if results.streaming.streamingSpeedup > 1.5 {
            strengths.append(.effectiveStreaming(results.streaming.streamingSpeedup))
        }
        
        // Check cache hit rate
        if results.cache.hitRate > 0.9 {
            strengths.append(.excellentCaching(results.cache.hitRate))
        }
        
        return strengths
    }
    
    private func analyzeResourceUtilization(_ results: BenchmarkSuiteResults) -> ResourceUtilizationAnalysis {
        return ResourceUtilizationAnalysis(
            memoryEfficiency: min(100.0, max(0.0, 100.0 - (results.memory.memoryLeakage / 10.0) * 100.0)),
            cpuUtilization: min(100.0, results.concurrency.concurrencySpeedup * 25.0), // Estimate
            gpuUtilization: results.metal.isMetalAvailable ? 80.0 : 0.0, // Estimate
            cacheEfficiency: results.cache.hitRate * 100.0
        )
    }
    
    private func analyzeScalability(_ results: BenchmarkSuiteResults) -> ScalabilityMetrics {
        return ScalabilityMetrics(
            concurrencyScaling: results.concurrency.concurrencySpeedup,
            batchScaling: results.embedding.batchSpeedup,
            streamingCapacity: results.streaming.streamingThroughput,
            memoryScaling: 100.0 / max(1.0, results.memory.peakMemoryUsage) // Inverse relationship
        )
    }
    
    private func generateRecommendations(_ results: BenchmarkSuiteResults, analysis: BenchmarkAnalysis) -> [PerformanceRecommendation] {
        var recommendations: [PerformanceRecommendation] = []
        
        // Analyze bottlenecks and generate recommendations
        for bottleneck in analysis.bottlenecks {
            switch bottleneck {
            case .highEmbeddingLatency(let latency):
                if latency > 0.1 {
                    recommendations.append(.optimizeModelSize("Consider using a smaller model for faster inference"))
                    recommendations.append(.enableMetalAcceleration("Enable Metal acceleration for GPU speedup"))
                }
                
            case .lowCacheHitRate(let rate):
                if rate < 0.7 {
                    recommendations.append(.improveCaching("Increase cache size or implement better cache warming"))
                }
                
            case .memoryLeaks(let leakage):
                if leakage > 10.0 {
                    recommendations.append(.fixMemoryLeaks("Investigate and fix memory leaks in the embedding pipeline"))
                }
                
            case .poorConcurrencyScaling(let scaling):
                if scaling < 1.5 {
                    recommendations.append(.optimizeConcurrency("Reduce synchronization overhead in concurrent operations"))
                }
            }
        }
        
        // General optimization recommendations
        if !results.metal.isMetalAvailable {
            recommendations.append(.enableMetalAcceleration("Consider enabling Metal for GPU acceleration"))
        }
        
        if results.streaming.streamingThroughput < results.embedding.batchEmbeddingThroughput {
            recommendations.append(.optimizeStreaming("Optimize streaming configuration for better throughput"))
        }
        
        return recommendations
    }
    
    // MARK: - Report Generation Methods
    
    private func generateSummarySection(_ report: BenchmarkReport) -> String {
        let score = report.analysis.overallPerformanceScore
        let scoreGrade = score > 80 ? "A" : score > 60 ? "B" : score > 40 ? "C" : "D"
        
        return """
        **Performance Score:** \(String(format: "%.1f", score))/100 (Grade \(scoreGrade))
        
        **Key Metrics:**
        - Single Embedding Latency: \(String(format: "%.2f", report.results.embedding.singleEmbeddingLatency * 1000))ms
        - Batch Throughput: \(String(format: "%.1f", report.results.embedding.batchEmbeddingThroughput)) ops/sec
        - Cache Hit Rate: \(String(format: "%.1f", report.results.cache.hitRate * 100))%
        - Concurrency Speedup: \(String(format: "%.1f", report.results.concurrency.concurrencySpeedup))x
        - Metal Available: \(report.results.metal.isMetalAvailable ? "Yes" : "No")
        """
    }
    
    private func generateEmbeddingSection(_ results: EmbeddingBenchmarkResults) -> String {
        return """
        ### Embedding Performance
        
        | Metric | Value |
        |--------|-------|
        | Single Embedding Latency | \(String(format: "%.2f", results.singleEmbeddingLatency * 1000))ms |
        | Single Embedding Throughput | \(String(format: "%.1f", results.singleEmbeddingThroughput)) ops/sec |
        | Batch Embedding Latency | \(String(format: "%.2f", results.batchEmbeddingLatency * 1000))ms |
        | Batch Embedding Throughput | \(String(format: "%.1f", results.batchEmbeddingThroughput)) ops/sec |
        | Variable Length Throughput | \(String(format: "%.1f", results.variableLengthThroughput)) ops/sec |
        | Batch Speedup | \(String(format: "%.1f", results.batchSpeedup))x |
        
        """
    }
    
    private func generateMetalSection(_ results: MetalBenchmarkResults) -> String {
        if !results.isMetalAvailable {
            return """
            ### Metal Acceleration
            
            ⚠️ **Metal not available on this device**
            
            """
        }
        
        return """
        ### Metal Acceleration
        
        | Operation | Speedup |
        |-----------|---------|
        | Normalization | \(String(format: "%.1f", results.normalizationSpeedup))x |
        | Pooling | \(String(format: "%.1f", results.poolingSpeedup))x |
        | Cosine Similarity | \(String(format: "%.1f", results.cosineSimilaritySpeedup))x |
        
        """
    }
    
    private func generateCacheSection(_ results: CacheBenchmarkResults) -> String {
        return """
        ### Cache Performance
        
        | Metric | Value |
        |--------|-------|
        | Write Latency | \(String(format: "%.3f", results.writeLatency * 1000))ms |
        | Hit Latency | \(String(format: "%.3f", results.hitLatency * 1000))ms |
        | Miss Latency | \(String(format: "%.3f", results.missLatency * 1000))ms |
        | Hit Rate | \(String(format: "%.1f", results.hitRate * 100))% |
        | Eviction Overhead | \(String(format: "%.3f", results.evictionOverhead * 1000))ms |
        
        """
    }
    
    private func generateStreamingSection(_ results: StreamingBenchmarkResults) -> String {
        return """
        ### Streaming Performance
        
        | Metric | Value |
        |--------|-------|
        | Streaming Throughput | \(String(format: "%.1f", results.streamingThroughput)) ops/sec |
        | Batch Streaming Throughput | \(String(format: "%.1f", results.batchStreamingThroughput)) ops/sec |
        | Memory Concurrency | \(String(format: "%.1f", results.memoryConcurrency)) |
        | Streaming Speedup | \(String(format: "%.1f", results.streamingSpeedup))x |
        
        """
    }
    
    private func generateModelManagementSection(_ results: ModelManagementBenchmarkResults) -> String {
        return """
        ### Model Management
        
        | Metric | Value |
        |--------|-------|
        | Registration Latency | \(String(format: "%.2f", results.registrationLatency * 1000))ms |
        | Version Lookup Latency | \(String(format: "%.2f", results.versionLookupLatency * 1000))ms |
        | Active Version Set Latency | \(String(format: "%.2f", results.activeVersionSetLatency * 1000))ms |
        
        """
    }
    
    private func generateMemorySection(_ results: MemoryBenchmarkResults) -> String {
        return """
        ### Memory Usage
        
        | Metric | Value |
        |--------|-------|
        | Baseline Memory | \(String(format: "%.1f", results.baselineMemory))MB |
        | Model Load Increase | \(String(format: "%.1f", results.modelLoadMemoryIncrease))MB |
        | Embedding Increase | \(String(format: "%.1f", results.embeddingMemoryIncrease))MB |
        | Cache Increase | \(String(format: "%.1f", results.cacheMemoryIncrease))MB |
        | Memory Leakage | \(String(format: "%.1f", results.memoryLeakage))MB |
        | Peak Memory Usage | \(String(format: "%.1f", results.peakMemoryUsage))MB |
        
        """
    }
    
    private func generateConcurrencySection(_ results: ConcurrencyBenchmarkResults) -> String {
        return """
        ### Concurrency Performance
        
        | Metric | Value |
        |--------|-------|
        | Sequential Time | \(String(format: "%.2f", results.sequentialTime))s |
        | Concurrent Time | \(String(format: "%.2f", results.concurrentTime))s |
        | Concurrency Speedup | \(String(format: "%.1f", results.concurrencySpeedup))x |
        | Optimal Concurrency | \(results.optimalConcurrency) threads |
        
        """
    }
    
    private func generateAnalysisSection(_ analysis: BenchmarkAnalysis) -> String {
        var section = "**Overall Performance Score:** \(String(format: "%.1f", analysis.overallPerformanceScore))/100\n\n"
        
        if !analysis.bottlenecks.isEmpty {
            section += "**Identified Bottlenecks:**\n"
            for bottleneck in analysis.bottlenecks {
                section += "- \(bottleneck.description)\n"
            }
            section += "\n"
        }
        
        if !analysis.strengths.isEmpty {
            section += "**Performance Strengths:**\n"
            for strength in analysis.strengths {
                section += "- \(strength.description)\n"
            }
            section += "\n"
        }
        
        return section
    }
    
    private func generateRecommendationsSection(_ recommendations: [PerformanceRecommendation]) -> String {
        if recommendations.isEmpty {
            return "No specific recommendations - performance is satisfactory."
        }
        
        var section = ""
        for (index, recommendation) in recommendations.enumerated() {
            section += "\(index + 1). \(recommendation.description)\n"
        }
        
        return section
    }
    
    // MARK: - Comparison Methods
    
    private func compareEmbedding(_ current: EmbeddingBenchmarkResults, _ baseline: EmbeddingBenchmarkResults) -> EmbeddingComparison {
        return EmbeddingComparison(
            latencyImprovement: (baseline.singleEmbeddingLatency - current.singleEmbeddingLatency) / baseline.singleEmbeddingLatency,
            throughputImprovement: (current.singleEmbeddingThroughput - baseline.singleEmbeddingThroughput) / baseline.singleEmbeddingThroughput,
            batchSpeedupImprovement: (current.batchSpeedup - baseline.batchSpeedup) / baseline.batchSpeedup
        )
    }
    
    private func compareMetal(_ current: MetalBenchmarkResults, _ baseline: MetalBenchmarkResults) -> MetalComparison {
        guard current.isMetalAvailable && baseline.isMetalAvailable else {
            return MetalComparison(normalizationImprovement: 0, poolingImprovement: 0, similarityImprovement: 0)
        }
        
        return MetalComparison(
            normalizationImprovement: (current.normalizationSpeedup - baseline.normalizationSpeedup) / baseline.normalizationSpeedup,
            poolingImprovement: (current.poolingSpeedup - baseline.poolingSpeedup) / baseline.poolingSpeedup,
            similarityImprovement: (current.cosineSimilaritySpeedup - baseline.cosineSimilaritySpeedup) / baseline.cosineSimilaritySpeedup
        )
    }
    
    private func compareCache(_ current: CacheBenchmarkResults, _ baseline: CacheBenchmarkResults) -> CacheComparison {
        return CacheComparison(
            hitRateImprovement: current.hitRate - baseline.hitRate,
            latencyImprovement: (baseline.hitLatency - current.hitLatency) / baseline.hitLatency
        )
    }
    
    private func compareStreaming(_ current: StreamingBenchmarkResults, _ baseline: StreamingBenchmarkResults) -> StreamingComparison {
        return StreamingComparison(
            throughputImprovement: (current.streamingThroughput - baseline.streamingThroughput) / baseline.streamingThroughput,
            speedupImprovement: (current.streamingSpeedup - baseline.streamingSpeedup) / baseline.streamingSpeedup
        )
    }
    
    private func compareModelManagement(_ current: ModelManagementBenchmarkResults, _ baseline: ModelManagementBenchmarkResults) -> ModelManagementComparison {
        return ModelManagementComparison(
            registrationImprovement: (baseline.registrationLatency - current.registrationLatency) / baseline.registrationLatency,
            lookupImprovement: (baseline.versionLookupLatency - current.versionLookupLatency) / baseline.versionLookupLatency
        )
    }
    
    private func compareMemory(_ current: MemoryBenchmarkResults, _ baseline: MemoryBenchmarkResults) -> MemoryComparison {
        return MemoryComparison(
            peakUsageImprovement: (baseline.peakMemoryUsage - current.peakMemoryUsage) / baseline.peakMemoryUsage,
            leakageImprovement: (baseline.memoryLeakage - current.memoryLeakage) / max(baseline.memoryLeakage, 0.001)
        )
    }
    
    private func compareConcurrency(_ current: ConcurrencyBenchmarkResults, _ baseline: ConcurrencyBenchmarkResults) -> ConcurrencyComparison {
        return ConcurrencyComparison(
            speedupImprovement: (current.concurrencySpeedup - baseline.concurrencySpeedup) / baseline.concurrencySpeedup,
            optimalConcurrencyChange: current.optimalConcurrency - baseline.optimalConcurrency
        )
    }
    
    private func calculateOverallImprovement(_ current: BenchmarkSuiteResults, _ baseline: BenchmarkSuiteResults) -> Double {
        // Weighted average of key improvements
        let weights: [Double] = [0.3, 0.2, 0.15, 0.15, 0.1, 0.1] // embedding, metal, cache, streaming, memory, concurrency
        
        let embeddingImprovement = (current.embedding.singleEmbeddingThroughput - baseline.embedding.singleEmbeddingThroughput) / baseline.embedding.singleEmbeddingThroughput
        let metalImprovement = current.metal.isMetalAvailable && baseline.metal.isMetalAvailable ? 
            (current.metal.normalizationSpeedup - baseline.metal.normalizationSpeedup) / baseline.metal.normalizationSpeedup : 0
        let cacheImprovement = current.cache.hitRate - baseline.cache.hitRate
        let streamingImprovement = (current.streaming.streamingThroughput - baseline.streaming.streamingThroughput) / baseline.streaming.streamingThroughput
        let memoryImprovement = (baseline.memory.peakMemoryUsage - current.memory.peakMemoryUsage) / baseline.memory.peakMemoryUsage
        let concurrencyImprovement = (current.concurrency.concurrencySpeedup - baseline.concurrency.concurrencySpeedup) / baseline.concurrency.concurrencySpeedup
        
        let improvements = [embeddingImprovement, metalImprovement, cacheImprovement, streamingImprovement, memoryImprovement, concurrencyImprovement]
        
        return zip(improvements, weights).map(*).reduce(0, +)
    }
}

// MARK: - Analysis Types

public struct BenchmarkReport: Sendable {
    public let results: BenchmarkSuiteResults
    public let analysis: BenchmarkAnalysis
    public let recommendations: [PerformanceRecommendation]
    public let generatedAt: Date
    
    public init(results: BenchmarkSuiteResults, analysis: BenchmarkAnalysis, recommendations: [PerformanceRecommendation], generatedAt: Date) {
        self.results = results
        self.analysis = analysis
        self.recommendations = recommendations
        self.generatedAt = generatedAt
    }
}

public struct BenchmarkAnalysis: Sendable {
    public let overallPerformanceScore: Double
    public let bottlenecks: [PerformanceBottleneck]
    public let strengths: [PerformanceStrength]
    public let resourceUtilization: ResourceUtilizationAnalysis
    public let scalabilityMetrics: ScalabilityMetrics
    
    public init(overallPerformanceScore: Double, bottlenecks: [PerformanceBottleneck], strengths: [PerformanceStrength], resourceUtilization: ResourceUtilizationAnalysis, scalabilityMetrics: ScalabilityMetrics) {
        self.overallPerformanceScore = overallPerformanceScore
        self.bottlenecks = bottlenecks
        self.strengths = strengths
        self.resourceUtilization = resourceUtilization
        self.scalabilityMetrics = scalabilityMetrics
    }
}

public enum PerformanceBottleneck: Sendable {
    case highEmbeddingLatency(TimeInterval)
    case lowCacheHitRate(Double)
    case memoryLeaks(Double)
    case poorConcurrencyScaling(Double)
    
    public var description: String {
        switch self {
        case .highEmbeddingLatency(let latency):
            return "High embedding latency: \(String(format: "%.2f", latency * 1000))ms"
        case .lowCacheHitRate(let rate):
            return "Low cache hit rate: \(String(format: "%.1f", rate * 100))%"
        case .memoryLeaks(let leakage):
            return "Memory leakage detected: \(String(format: "%.1f", leakage))MB"
        case .poorConcurrencyScaling(let scaling):
            return "Poor concurrency scaling: \(String(format: "%.1f", scaling))x"
        }
    }
}

public enum PerformanceStrength: Sendable {
    case metalAcceleration(Double)
    case efficientBatchProcessing(Double)
    case effectiveStreaming(Double)
    case excellentCaching(Double)
    
    public var description: String {
        switch self {
        case .metalAcceleration(let speedup):
            return "Excellent Metal acceleration: \(String(format: "%.1f", speedup))x average speedup"
        case .efficientBatchProcessing(let speedup):
            return "Efficient batch processing: \(String(format: "%.1f", speedup))x speedup"
        case .effectiveStreaming(let speedup):
            return "Effective streaming: \(String(format: "%.1f", speedup))x speedup"
        case .excellentCaching(let hitRate):
            return "Excellent caching: \(String(format: "%.1f", hitRate * 100))% hit rate"
        }
    }
}

public enum PerformanceRecommendation: Sendable {
    case optimizeModelSize(String)
    case enableMetalAcceleration(String)
    case improveCaching(String)
    case fixMemoryLeaks(String)
    case optimizeConcurrency(String)
    case optimizeStreaming(String)
    
    public var description: String {
        switch self {
        case .optimizeModelSize(let details),
             .enableMetalAcceleration(let details),
             .improveCaching(let details),
             .fixMemoryLeaks(let details),
             .optimizeConcurrency(let details),
             .optimizeStreaming(let details):
            return details
        }
    }
}

public struct ResourceUtilizationAnalysis: Sendable {
    public let memoryEfficiency: Double
    public let cpuUtilization: Double
    public let gpuUtilization: Double
    public let cacheEfficiency: Double
    
    public init(memoryEfficiency: Double, cpuUtilization: Double, gpuUtilization: Double, cacheEfficiency: Double) {
        self.memoryEfficiency = memoryEfficiency
        self.cpuUtilization = cpuUtilization
        self.gpuUtilization = gpuUtilization
        self.cacheEfficiency = cacheEfficiency
    }
}

public struct ScalabilityMetrics: Sendable {
    public let concurrencyScaling: Double
    public let batchScaling: Double
    public let streamingCapacity: Double
    public let memoryScaling: Double
    
    public init(concurrencyScaling: Double, batchScaling: Double, streamingCapacity: Double, memoryScaling: Double) {
        self.concurrencyScaling = concurrencyScaling
        self.batchScaling = batchScaling
        self.streamingCapacity = streamingCapacity
        self.memoryScaling = memoryScaling
    }
}

// MARK: - Comparison Types

public struct BenchmarkComparison: Sendable {
    public let embedding: EmbeddingComparison
    public let metal: MetalComparison
    public let cache: CacheComparison
    public let streaming: StreamingComparison
    public let modelManagement: ModelManagementComparison
    public let memory: MemoryComparison
    public let concurrency: ConcurrencyComparison
    public let overallImprovement: Double
    
    public init(embedding: EmbeddingComparison, metal: MetalComparison, cache: CacheComparison, streaming: StreamingComparison, modelManagement: ModelManagementComparison, memory: MemoryComparison, concurrency: ConcurrencyComparison, overallImprovement: Double) {
        self.embedding = embedding
        self.metal = metal
        self.cache = cache
        self.streaming = streaming
        self.modelManagement = modelManagement
        self.memory = memory
        self.concurrency = concurrency
        self.overallImprovement = overallImprovement
    }
}

public struct EmbeddingComparison: Sendable {
    public let latencyImprovement: Double
    public let throughputImprovement: Double
    public let batchSpeedupImprovement: Double
    
    public init(latencyImprovement: Double, throughputImprovement: Double, batchSpeedupImprovement: Double) {
        self.latencyImprovement = latencyImprovement
        self.throughputImprovement = throughputImprovement
        self.batchSpeedupImprovement = batchSpeedupImprovement
    }
}

public struct MetalComparison: Sendable {
    public let normalizationImprovement: Double
    public let poolingImprovement: Double
    public let similarityImprovement: Double
    
    public init(normalizationImprovement: Double, poolingImprovement: Double, similarityImprovement: Double) {
        self.normalizationImprovement = normalizationImprovement
        self.poolingImprovement = poolingImprovement
        self.similarityImprovement = similarityImprovement
    }
}

public struct CacheComparison: Sendable {
    public let hitRateImprovement: Double
    public let latencyImprovement: Double
    
    public init(hitRateImprovement: Double, latencyImprovement: Double) {
        self.hitRateImprovement = hitRateImprovement
        self.latencyImprovement = latencyImprovement
    }
}

public struct StreamingComparison: Sendable {
    public let throughputImprovement: Double
    public let speedupImprovement: Double
    
    public init(throughputImprovement: Double, speedupImprovement: Double) {
        self.throughputImprovement = throughputImprovement
        self.speedupImprovement = speedupImprovement
    }
}

public struct ModelManagementComparison: Sendable {
    public let registrationImprovement: Double
    public let lookupImprovement: Double
    
    public init(registrationImprovement: Double, lookupImprovement: Double) {
        self.registrationImprovement = registrationImprovement
        self.lookupImprovement = lookupImprovement
    }
}

public struct MemoryComparison: Sendable {
    public let peakUsageImprovement: Double
    public let leakageImprovement: Double
    
    public init(peakUsageImprovement: Double, leakageImprovement: Double) {
        self.peakUsageImprovement = peakUsageImprovement
        self.leakageImprovement = leakageImprovement
    }
}

public struct ConcurrencyComparison: Sendable {
    public let speedupImprovement: Double
    public let optimalConcurrencyChange: Int
    
    public init(speedupImprovement: Double, optimalConcurrencyChange: Int) {
        self.speedupImprovement = speedupImprovement
        self.optimalConcurrencyChange = optimalConcurrencyChange
    }
}

// MARK: - Extensions

extension DateFormatter {
    static let iso8601: DateFormatter = {
        let formatter = DateFormatter()
        formatter.dateFormat = "yyyy-MM-dd'T'HH:mm:ss'Z'"
        formatter.timeZone = TimeZone(secondsFromGMT: 0)
        return formatter
    }()
}